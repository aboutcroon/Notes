## 数据结构

线性结构：数组，栈，队列，链表等

非线性结构：树，堆，图等



各种数据结构，不管是队列，栈等线性数据结构还是树，图的等非线性数据结构，从根本上底层都是 `数组` 和 `链表`。不管你用的是数组还是链表，用的都是计算机内存，物理内存是一个个大小相同的内存单元构成的。



**数组**是连续的内存空间

**链表**是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。



## 1. 链表

数组是一块连续的空间，数组的每一项都是紧密相连的，因此如果要执行插入和删除操作就很麻烦。

对数组头部的插入和删除时间复杂度都是 `O(N)`，而平均复杂度也是 `O(N)`，只有对尾部的插入和删除才是`O(1)`。简单来说就是**数组对查询特别友好，对删除和添加不友好**。为了解决这个问题，就有了**链表**这种数据结构。



链表适合的场景：

1. 既需要数据有一定顺序
2. 又需要对数据进行频繁增删的场景

> 链表只有一个后驱节点 next，如果是双向链表还会有一个前驱节点 pre。
>
> 为什么只有二叉树，而没有一叉树？因为实际上链表就是特殊的树，即一叉树。



### 插入

插入只需要考虑要插入位置前驱节点和后继节点即可，其他节点不受影响，因此在给定指针的情况下插入的操作时间复杂度为`O(1)`。这里给定指针中的指针指的是**插入位置的前驱节点**。

若给定指针，伪代码如下：

```
temp = 待插入位置的前驱节点.next
待插入位置的前驱节点.next = 待插入指针
待插入指针.next = temp
```

以上步骤图如下：

<img src="/Users/liuchang/Documents/markdown/学习/算法/算法.assets/2-1.JPG" alt="2-1" style="zoom:50%;" />

如果没有给定指针，我们需要先遍历找到节点，因此最坏情况下时间复杂度为 `O(N)`。

### 删除

只需要将需要删除的节点的前驱指针的 next 指针修正为其下下个节点即可，注意考虑**边界条件**。

伪代码如下：

```
待删除位置的前驱节点.next = 待删除位置的前驱节点.next.next
```

### 遍历

比较简单，迭代伪代码如下：

```
当前指针 =  头指针
while 当前节点不为空 {
   print(当前节点)
   当前指针 = 当前指针.next
}
```

一个前序遍历的递归的伪代码：

```
dfs(cur) {
    if 当前节点为空 return
    print(cur.val)
    return dfs(cur.next)
}
```



链表的话，很多语言没有内置的数组类型。力扣通常使用如下的类来模拟：

```js
 public class ListNode {
   int val;
   ListNode next;
   ListNode() {}
   ListNode(int val) { this.val = val; }
   ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 }
```



### 考点

1. 指针的修改
2. 链表的拼接



#### 指针的修改

指针的修改通常就是反转任意一段链表

由于链表的递归性，实际上，我们只要反转其中相邻的两个，剩下的采用同样的方法完成即可，反转两个如下

```js
next = cur.next // 暂存下一个节点
cur.next = pre
pre = cur
cur = next // 下一个节点变成cur
```



以 head 为开头，以 tail 为结尾。如果 head 是整个链表的头，tail 是整个链表的尾，那就是反转整个链表，否则就是反转局部链表。

反转链表我们可以写出如下代码：

```js
// terminal 是 tail 节点的下一个节点，这样可以让边界的 tail 也进行反转
function reverse (head: ListNode, tail: ListNode, terminal: ListNode) {
  cur = head
  pre = None
  while (cur !== terminal) {
    next = cur.next // 留下联系方式
    cur.next = pre // 修改指针
    // 继续往下走
    pre = cur
    cur = next
  }
  // 反转后的新的头尾节点返回出去
  return {
    head,
    tail
  }
}
```



### 注意

链表最容易出错的地方就是我们应该注意的地方。链表最容易出的错 90 % 集中在以下三种情况：

- 出现了环，造成死循环。
- 分不清边界，导致边界条件出错。
- 搞不懂递归怎么做



#### 环

环的考点有两个：

- 题目就有可能环，让你判断是否有环，以及环的位置。
- 题目链表没环，但是被你操作指针整出环了。

这里我们只讨论第二种，而第一种可以用我们后面提到的**快慢指针算法**。

#### 边界

很多人错的是没有考虑边界。一个考虑边界的技巧就是看题目信息。

- 如果题目的头节点可能被移除，那么考虑使用虚拟节点，这样**头节点就变成了中间节点**，就不需要为头节点做特殊判断了。
- 题目让你返回的不是原本的头节点，而是尾部节点或者其他中间节点，这个时候要注意指针的变化。

以上两者部分的具体内容，我们在稍后讲到的虚拟头部分讲解。老规矩，大家留个印象即可。

### 前后序

要搞懂递归怎么做，则要明白前后序。

> 绝大多数的题目都是单链表，而单链表只有一个后继指针。因此只有前序和后序，没有中序遍历。



## 2. 树

数的每个节点都可以用以下数据结构来表示：

```ts
Node {
  value: any; // 当前节点的值
  children: Array<Node>; // 指向其儿子
}
```

其他重要概念：

- 树的高度：节点到叶子节点的最大值就是其高度。
- 树的深度：高度和深度是相反的，**高度是从下往上数，深度是从上往下。**因此根节点的深度和叶子节点的高度是 0。
- 树的层：根开始定义，根为第一层，根的孩子为第二层。
- 二叉树，三叉树，。。。 N 叉树，由其子节点最多可以有几个决定，最多有 N 个就是 N 叉树。



### 二叉树

二叉树可以用以下数据结构表示：

```js
Node {
  value: any; // 当前节点的值
  left: Node | null; // 左儿子
  right: Node | null; // 右儿子
}
```



二叉树分类：

- 完全二叉树
- 满二叉树
- 二叉搜索树
- 平衡二叉树
- 红黑树
- ...



二叉树的表示：

- 链表存储
- 数组存储。非常适合完全二叉树



## 深度优先遍历

一个树的 DFS 模版：

```js
function dfs (root) {
  if (满足特定条件）{
    // 返回结果 or 退出搜索空间
  }
  for (const child of root.children) {
    dfs(child)
  }
}
```

而几乎所有的题目几乎都是二叉树，因此下面这个模板更常见：

```js
// 前序遍历
function dfs(root) {
  if (满足特定条件）{
    // 返回结果 or 退出搜索空间
  }
  // 主要逻辑
  dfs(root.left)
  dfs(root.right)
}

// 后序遍历
function dfs(root) {
  if (满足特定条件）{
    // 返回结果 or 退出搜索空间
  }
  dfs(root.left)
  dfs(root.right)
  // 主要逻辑
}
```

如果代码的**主逻辑**在左右子树之前执行，那么就是前序遍历。如果代码主逻辑在左右子树之后执行，那么就是后序遍历。

