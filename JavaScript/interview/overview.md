![overview](https://raw.githubusercontent.com/aboutcroon/Notes/main/JavaScript/interview/assets/js%20overview.png)

## 8. 面向对象



## 9. 垃圾回收与内存泄漏

### 垃圾回收的概念

#### 垃圾回收

JavaScript 代码运行时，需要分配内存空间来储存变量和值。当变量不再参与运行时，就需要系统收回被占用的内存空间，这就是垃圾回收。

#### 回收机制

JS 引擎中有一个后台进程称为垃圾回收器，它监视所有对象，观察对象是否可被访问，然后按照固定的时间间隔周期性的删除掉那些不可访问的对象即可。



### 垃圾回收的方式

现在各大浏览器通常用采用的垃圾回收方式有两种：

#### 引用计数

最早最简单的垃圾回收机制，就是给一个占用物理空间的对象附加一个引用计数器，当有其它对象引用这个对象时，这个对象的引用计数加 1，反之解除时就减 1，当该对象引用计数为 0 时就会被回收。

该方式很简单，但会引起内存泄漏：

```js
// 循环引用的问题
function temp () {
    const obj1 = {}
    const obj2 = {}
    obj1.a = obj2 // obj1 引用 obj2
    obj2.a = obj1 // obj2 引用 obj1
}
```

这种情况下每次调用 `temp` 函数，`obj1` 和 `obj2` 的引用计数都是 `2` ，会使这部分内存永远不会被释放，即内存泄漏。现在已经很少使用了，只有低版本的 IE 使用这种方式。

> 只能手动释放变量占用的内存：
>
> ```js
> obj1.a = null
> obj2.a = null
> ```

#### 标记清除

V8 引擎中主垃圾回收器就采用标记清除法进行垃圾回收。主要流程如下：

1. 在变量进入执行上下文时打上“进入”标记
2. 同时在变量离开执行上下文时也打上“离开”标记
3. 标记为“离开”的变量，从此以后是无法访问这个变量的，在下一次垃圾回收时该变量占用的内存将会被释放

> 所以我们需要尽可能的使用 const 和 let，因为 const 和 let 使 JS 有了块级作用域，当块级作用域比函数作用域更早结束时，垃圾回收器可以更早介入。

![mark and sweep](https://raw.githubusercontent.com/aboutcroon/Notes/main/JavaScript/interview/assets/mark%20and%20sweep.webp)

> 拓展
>
> 如果一个对象被多次引用时，例如作为另一对象的键、值或子元素时，将该对象引用设置为 `null` 时，该对象是不会被回收的，依然存在。例如：
>
> ```javascript
> let a = {}
> let arr = [a]
> 
> a = null;
> console.log(arr)
> // [{}]
> ```
>
> 如果作为 `Map` 的键呢？则也是如此，ES6 考虑到了这一点，推出了： `WeakMap` 。它对于值的引用都是不计入垃圾回收机制的，所以名字里面才会有一个"Weak"，表示这是弱引用（对对象的弱引用是指当该对象应该被GC回收时不会阻止GC的回收行为）。
>
> `Map` 相对于 `WeakMap` ：
>
> - `Map` 的键可以是任意类型，`WeakMap` 只接受对象作为键（null除外），不接受其他类型的值作为键。
> - `Map` 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键； `WeakMap` 的键是弱引用，键所指向的对象可以被垃圾回收，**此时键是无效的**。
> - `Map` 可以被遍历， `WeakMap` 不能被遍历。

### 如何减少垃圾回收

当代码比较复杂时，浏览器进行垃圾回收的代价会变得比较大，所以应该尽量减少垃圾回收。

- 数组优化：在清空一个数组时，我们可以尽量将数组长度设为 0，`arr.length = 0`，而不是 `arr = []`，这样会创建一个新的空对象，对垃圾回收不友好。
- 对象优化：对象尽量复用，对于不再使用的对象，将其设置为 null 使之尽快被回收。
- 函数优化：在循环中的函数表达式，如果有可以复用的部分，尽量放在函数的外面。

### 哪些情况会导致内存泄漏

1. **意外的全局变量**
2. **被遗忘的计时器或回调函数**：设置了 setInterval 定时器，而忘记取消它，如果定时器的回调函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。
3. **脱离 DOM 的引用**：获取一个 DOM 元素的引用，而后这个 DOM 元素被删除，那么由于一直保留了对这个元素的引用，那么它也将无法被回收。
4. **不合理的闭包**：使用闭包的方式不合理时，将导致某些变量一直被引用从而一直无法被回收。



